# 객제지향프로그래밍

## 1. 정의

- 객체지향 프로그래밍(*Obejckt Oriented Programming*)은 문제를 여러 개의 객체 단위로 나눠 작업하는 방식.

- **상태와 행위를 가진 객체**를 만들고, 그 **객체들 간 유기적인** 

  **상호 작용**을 통해 로직을 구성하는 프로그래밍 방법
  
  객체(*object*)

> 객체(object)란 간단히 이야기하자면 실생활에서 우리가 인식 할 수 있는 
>
> 사물로 설명할 수 있다.  이러한 객체의 상태(state)와 행동(behavior)을 구체화하는
>
> 형태의 프로그래밍이 바로 객체 지향 프로그래밍. 이때 객체를 만들어 내기 위한 
>
> 설계도와 같은 개념을 클래스(class)라고 한다. 

- 상태와 행위를 가진 객체들을 만들고, 하나의 프로그램을 만드는 것을 객체지향 프로그래밍이라 할 수 있다.

  ## 2. 특징 및 장,단점

  **특징**

  - 객체지향 프로그래밍의 가장 큰 특징은 **클래스를 이용**해 연관 있는 **처리부분(함수)**과 **데이터 부분(변수)**를 이용해 하나로 묶어 **객체(인스턴스)를 생성**해 사용.

  

  **장점** 

  - 코드 재사용이 용이

    => 기존에 만들어진 클래스를 재사용할 수 있고 상속을 통해 확장 가능

  - 유지 보수가 편리

    => 수정해야할 부분이 클래스 내부에 있으므로 해당 부분만 수정

  - 대형 프로젝트에 적합

    => 클래스 단위로 모듈화 시켜서 개발 -> 업무 분담의 편리성 향상

  

  **단점**

  - 처리속도가 상대적으로 느림 

  - 객체의 수 증가 -> 용량이 커질 수 있음

  - 설계시 많은 시간과 노력이 필요

    => 좋은 객체를 만드는 것은 다른 말로 설계를 잘하는 법이라고 할 수 있는데, 좋은 설계는 현실을 잘 반영해야 한다.

    ## 3. 객체 지향 키워드 5가지

    ### 클래스 + 인스턴스(객체)

  ​	추상화를 거쳐 집단에 속하는 속성과 행위를 **변수와 매소드로 정의**한 것

  - 어떠한 객체의 상태를 나타내는 **변수**와 행동을 나타내는 **메소드**의 집합
  - 객체를 정의하는 틀, 설계도
  
  

  인스턴스(객체)

  클래스에서 정의한 것을 토대로 실제 메모리상에 할당 된 것.

  클래스로부터 객체를 선언하는 과정을 **클래스 인스턴스화**라고 한다.

  

  ### 추상화(자료의 추상화)

  불필요한 정보는 놔두고, 중요한 정보만을 표시함으로써 공통의 속성이나 기능을 묶어

  붙이는 것. 물고기 사자, 토끼, 뱀이라는 이름을 가진 객체가 각각 있고 이 객체들을 하나로 묶을려 할 때, 동물 또는 생물이라는 추상적인 객체로 크게 정의하여 묶는 것을 추상화 라고 한다.

  ### 캡슐화

  데이터 구조와 데이터를 다루는 방법들을 결합시켜 묶는 것.

  => **변수**와 **함수**를 하나로 묶는 것을 뜻한다.

  캡슐화는 관련있는 변수와 함수를 하나의 클래스로 묶고 외부에서 쉽게 접근하지 못하도록 

  **정보 은닉**을 하는게 핵심. 

  객체에 직접적인 접근을 막고 외부에서 내부의 정보에 직접접근하거나 변경할 수 없고, 객체가 제공하는 필드와 메소드를 통해서만 접근 가능.

  ▷ **클래스 접근 제어자**

  default : 동일 패키지의 클래스(class)에만 인스턴스(객체)를 생성가능하다.

  public : 다른 패키지에서 인스턴스(객체)를 생성가능.

  **▷ 메소드 접근 제어자**

  private : 동일한 클래스 안에서만 접근이 가능하고, this를 사용하는 것들은 외부에서 접근 불가능하고, 상속도 안됨.

  default : 접근제어자가 없는 형태로 동일한 패키지 안에서만 접근이 가능.

  protected : 동일한 패키지 안에서 사용가능하고, 다른 패키지라도 상속받은 클래스에는 접근이 가능

  public : 모든 객체에서 접근 가능

  ### 4)상속

  **상위 개념의 특징을 하위 개념이 물려 받은 것**

  부모 클래스의 속성과 기능을 그대로 물려받아 사용할 수 있고, 기능의 일부분을 변경해야 할 경우 상속받은 자식 클래스에서 해당 기능만 다시 수정하여 사용할 수 있다.

  ### 5) 다형성

  하나의 변수명, 함수명등이 상황에 따라 다른 의미로 해석될 수 있는 것.

  - 오버라이딩 : 부모 클래스의 메소드와 같은 이름, 매개변수를 재정의 하는 것

  - 오버로딩 : 같은 이름의 함수를 여러개 정의 하고 매개 변수의 타입과 개수를 다르게 하여

    매개변수에 따라 다르게 호출할 수 있도록 하는 것.

  ### +) getter, setter 사용 이유

  getter,setter를 사용하면 메소드를 통해 접근하기 때문에, 올바르지 않은 입력에 

  대해 사전에 처리할 수 있도록 제한 하거나 조절 할 수 있기 때문이다.

  ---

  ## 클래스의 구성 멤버{

  ### 생성자(Constructor)

  - 객체 생성 시 초기화 역할 담당
  - 객체가 객체화 될 때 호출되는 특수 함수,  새 키워드를 사용할 때 자바 생성자의 목적은 새로 생성된 객체를 쓰기전에 초기화하는 것.
  - 생성자는 해당 클래스의 인스턴스를 초기화 한다.
  - 일반적으로는 생성자는 초기화가 필요한 객체의 필드를 초기화 한다
  
  

  ### 메소드(Method)

  - 다른 프로그래밍 언어에는 **함수**가 별도로 존재한다. 하지만 자바는 클래스를 떠나 존재하는 것은 있을 수 없기 떄문에 자바의 함수는 따로 존재하지 않고 클래스 내에 존재.
  - 이러한 클래스 내의 함수를 **메소드**라고 한다.
  
  1. 메소드 선언

  public static 리턴타입(자료형, void) 메서드명()

  {

  메서드 작성 return 리턴 데이터;

  }

  메서드를 사용하기 위해서는 메서드를 선언.

  위와 같이 선언.

  **리턴타입**에는 int, string, boolean 등의 자료형을 넣어준다.

  리턴타입에 void가 들어가는 경우 return받는 데이터가 없다는 것을 의미.

  2. 메소드 호출

  메소드명();

  메서드를 호출하는 방법은 간단.

  메소드(); 으로 호출하면 된다.

  ### 필드(Field)

  - 객체의 데이터가 저장되는 곳

  - 선언 형태는 변수(variable)와 비슷 하지만,

    필드를 변수라 부르진 않는다.

  - 변수는 생성자와 메소드 내에서만 사용되고 생성자와 메소드가 실행 종료되면 자동 소멸

  - 필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재.

  ## }

## 변수 종류(지역변수, 전역변수, 클래스변수, 인스턴스 변수)

| 변수의 종류                      | 선언 위치                    | 생성 시기                   |
| -------------------------------- | ---------------------------- | --------------------------- |
| 클래스 변수                      | 클래스 영역                  | 클래스가 메모리에 올라 갈때 |
| 인스턴스 변수                    | 클래스 영역                  | 인스턴스가 생성되었을 때    |
| 지역 변수                        |                              |                             |
| 클래스 영역 이외의 영역          |                              |                             |
| 메소드, 생성자, 초기화 블록 내부 | 변수 선언문이 수행 되었을 때 |                             |

```java
public class Test { 
public static void main(String[] args) { 
int i = 0; 
while(i<1) { 
int result = 100; 
i++; 
System.out.println(result); 
} 
//System.out.println(result); 
} 
}
```

- 전역변수는 함수 바깥에 선언하여 클래스 전체에서 사용 가능한 변수
- 지역변수는 함수 속에 선언하여 해당 함수 속에서만 사용가능한 변수

(+ 여기서는 i는 “전역변수”, var는 “지역변수”)

